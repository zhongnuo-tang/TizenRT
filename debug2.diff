diff --git a/os/arch/arm/src/common/up_createstack.c b/os/arch/arm/src/common/up_createstack.c
index 2595d047a..abdfb62eb 100644
--- a/os/arch/arm/src/common/up_createstack.c
+++ b/os/arch/arm/src/common/up_createstack.c
@@ -146,7 +146,7 @@
 int up_create_stack(FAR struct tcb_s *tcb, size_t stack_size, uint8_t ttype)
 {
 	size_t stack_alloc_size = stack_size;
-
+	lldbg("stack_size %d\n",stack_size);
 	/* new thread does not have the uheap value yet, It's added in the task_
 	 * schedsetup function.
 	 * Parent and child threads must have the same uheap value, so we are
@@ -203,7 +203,7 @@ int up_create_stack(FAR struct tcb_s *tcb, size_t stack_size, uint8_t ttype)
 		/* Was the allocation successful? */
 
 		if (!tcb->stack_alloc_ptr) {
-			sdbg("ERROR: Failed to allocate stack, size %d\n", stack_size);
+			lldbg("ERROR: Failed to allocate stack, size %d\n", stack_size);
 		}
 #endif
 	}
@@ -251,12 +251,12 @@ int up_create_stack(FAR struct tcb_s *tcb, size_t stack_size, uint8_t ttype)
 
 		/* Adjust stack size after guard_size calculation */
 		size_of_stack = size_of_stack - CONFIG_MPU_STACK_GUARD_SIZE;
-
+		lldbg("254\n");
 		/* Save the adjusted stack values in the struct tcb_s */
 		tcb->adj_stack_ptr = (uint32_t *)top_of_stack;
 		tcb->stack_base_ptr = tcb->stack_alloc_ptr;
 		tcb->adj_stack_size = size_of_stack;
-
+		lldbg("tcb->stack_base_ptr %x\n",tcb->stack_base_ptr);
 		/* If stack debug is enabled, then fill the stack with a
 		 * recognizable value that we can use later to test for high
 		 * water marks.
diff --git a/os/kernel/init/os_start.c b/os/kernel/init/os_start.c
index 299ca856f..8c9177098 100644
--- a/os/kernel/init/os_start.c
+++ b/os/kernel/init/os_start.c
@@ -426,7 +426,9 @@ void os_start(void)
 	int i;
 
 	slldbg("Entry\n");
-
+	for (int i = 0; i < 1<<24; i++){
+		asm("nop");
+	}
 	g_os_initstate = OSINIT_BOOT;
 
 	/* Initialize RTOS Data ************************************************** */
@@ -655,14 +657,14 @@ void os_start(void)
 	g_lastpid = CONFIG_SMP_NCPUS - 1;
 
 	/* Fill the stack information to Idle task's tcb */
-lldbg("595\n");
-DelayMs(10);
 	g_idletcb[0].cmn.adj_stack_size = CONFIG_IDLETHREAD_STACKSIZE;
 	g_idletcb[0].cmn.stack_alloc_ptr = (void *)(g_idle_topstack - CONFIG_IDLETHREAD_STACKSIZE);
 	g_idletcb[0].cmn.adj_stack_ptr = (void *)(g_idle_topstack - 4);
-lldbg("596\n");
-DelayMs(10);
 	DEBUGASSERT(up_getsp() >= (uint32_t)g_idletcb[0].cmn.stack_alloc_ptr && up_getsp() <= (uint32_t)g_idletcb[0].cmn.adj_stack_ptr);
+	lldbg("g_idle_topstack %x\n",g_idle_topstack);
+	lldbg("g_idletcb[0].cmn.adj_stack_size %d\n",g_idletcb[0].cmn.adj_stack_size);
+	lldbg("g_idletcb[0].cmn.stack_alloc_ptr %x\n",g_idletcb[0].cmn.stack_alloc_ptr);
+	lldbg("g_idletcb[0].cmn.adj_stack_ptr %x\n",g_idletcb[0].cmn.adj_stack_ptr);
 
 	/* The memory manager is available */
 
@@ -716,7 +718,7 @@ DelayMs(10);
 	if (clock_initialize != NULL)
 #endif
 	{
-		// clock_initialize();
+		clock_initialize();
 	}
 #ifndef CONFIG_DISABLE_POSIX_TIMERS
 #ifdef CONFIG_HAVE_WEAKFUNCTIONS
@@ -821,7 +823,6 @@ lldbg("18\n");
 		if (i > 0)
 		{
 			/* Clone stdout, stderr, stdin from the CPU0 IDLE task. */
-lldbg("19\n");
 
 			DEBUGVERIFY(group_setuptaskfiles(&g_idletcb[i]));
 		}
@@ -907,7 +908,6 @@ lldbg("22\n");
 		pm_idle();
 #endif
 		/* Perform any processor-specific idle state operations */
-lldbg("23\n");
 
 		up_idle();
 	}
diff --git a/os/kernel/sched/sched_addreadytorun.c b/os/kernel/sched/sched_addreadytorun.c
index a133be867..ffd2aeaab 100644
--- a/os/kernel/sched/sched_addreadytorun.c
+++ b/os/kernel/sched/sched_addreadytorun.c
@@ -122,7 +122,7 @@ bool sched_addreadytorun(FAR struct tcb_s *btcb)
 {
 	FAR struct tcb_s *rtcb = this_task();
 	bool ret;
-
+	lldbg("rtcb %x\n", *rtcb);
 #ifdef CONFIG_SW_STACK_OVERFLOW_DETECTION
 	sched_checkstackoverflow(rtcb);
 #endif
diff --git a/os/kernel/task/task_create.c b/os/kernel/task/task_create.c
index bf260df72..dde2bb58b 100644
--- a/os/kernel/task/task_create.c
+++ b/os/kernel/task/task_create.c
@@ -135,6 +135,7 @@ static int thread_create(FAR const char *name, uint8_t ttype, int priority, int
 	pid_t pid;
 	int errcode;
 	int ret;
+	lldbg("enter\n");
 
 	/* Check whether we are allowed to create new task ? */
 	if (g_alive_taskcount == CONFIG_MAX_TASKS) {
